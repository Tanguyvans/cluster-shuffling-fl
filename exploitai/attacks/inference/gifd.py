"""
GIFD Attack Wrapper

Wrapper for GIFD (Gradient Inversion from Federated Learning) attacks.
This imports from the gifd_core module.
"""

from typing import Optional, Dict, Any, List, Tuple
import torch
import torch.nn as nn

try:
    from .gifd_core import GradientReconstructor
    GIFD_AVAILABLE = True
except ImportError:
    GIFD_AVAILABLE = False
    GradientReconstructor = None


class GIFDAttack:
    """
    GIFD (Gradient Inversion from Federated Learning) Attack

    Advanced gradient inversion with feature domain optimization.
    """

    def __init__(
        self,
        model: nn.Module,
        device: str = 'cpu',
        generator: Optional[str] = None,
        dataset: str = 'FFHQ64',
        cost_fn: str = 'sim_cmpr0',
        max_iterations: int = 1000,
        learning_rate: float = 0.1,
        num_restarts: int = 1,
        total_variation: float = 1e-1,
        image_norm: float = 1e-1,
        bn_stat: float = 1e-1,
        group_lazy: float = 1e-1,
        z_norm: float = 0.0,
        gias: bool = False,
        gifd: bool = False,
        verbose: bool = True
    ):
        if not GIFD_AVAILABLE:
            raise ImportError("GIFD not available. Make sure gifd_core is properly installed.")

        self.device = device
        self.config = {
            'cost_fn': cost_fn,
            'optim': 'adam',
            'restarts': num_restarts,
            'max_iterations': max_iterations,
            'lr': learning_rate,
            'total_variation': total_variation,
            'image_norm': image_norm,
            'bn_stat': bn_stat,
            'group_lazy': group_lazy,
            'z_norm': z_norm,
            'gias': gias,
            'gifd': gifd
        }

        # Set generator and dataset
        if generator:
            self.config['generative_model_name'] = generator
        if dataset:
            self.config['dataset'] = dataset

        # Initialize the reconstructor
        self.reconstructor = GradientReconstructor(model, (0.5, 0.5, 0.5), (0.5, 0.5, 0.5), self.config, num_images=1)

    def attack(
        self,
        gradients: List[torch.Tensor],
        input_shape: Tuple[int, ...],
        num_classes: int,
        labels: Optional[torch.Tensor] = None
    ) -> Dict[str, Any]:
        """
        Perform GIFD attack.

        Args:
            gradients: List of gradient tensors
            input_shape: Shape of input images (C, H, W)
            num_classes: Number of output classes
            labels: Optional known labels

        Returns:
            Dictionary with reconstructed data and metadata
        """
        try:
            # Prepare labels
            if labels is not None:
                labels_list = labels.tolist()
            else:
                labels_list = [-1]  # Unknown labels

            # Run reconstruction
            output, stats = self.reconstructor.reconstruct(
                gradients,
                labels_list,
                img_shape=input_shape
            )

            return {
                'data': output,
                'labels': labels,
                'success': output is not None,
                'stats': stats,
                'attack_type': 'GIFD' if self.config.get('gifd') else 'GIAS'
            }

        except Exception as e:
            return {
                'data': None,
                'labels': None,
                'success': False,
                'error': str(e),
                'attack_type': 'GIFD'
            }
